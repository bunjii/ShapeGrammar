using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text;
using System.Threading.Tasks;
using SimpleShapeGrammar.Classes;

namespace SimpleShapeGrammar.Classes
{
    /// <summary>
    /// Utility class for methods related to the multi-objective optimisation
    /// </summary>
    [Serializable]
    public static class MOO_Utility
    {
        public static List<SH_Rule> NewGenome(List<object> rules, List<double> weights, Random random, SH_SimpleShape _ss)
        {
            
            List<SH_Rule> genome = new List<SH_Rule>(); // instantiate the list for the genome
            int numLines = 1; // count the maximum number of line elements in generated by this genome.
            
            State state = State.alpha; // set the initial state of the rules
            int count = 0;
            // add rules to the genome
            while (state != State.end ) 
            {
                SH_UtilityClass.TakeRandomItem(rules, weights, random, out var listElement);
                var ruleString = listElement as string;
                if (ruleString != null)
                {
                    var ruleObject = NewRule(ruleString) as SH_Rule;
                    // test that the casting worked
                    if (ruleObject != null)
                    {
                        // for the rule to be added, it must comply with the current state. 
                        if (ruleObject.RuleState == state)
                        {
                            // Remove the below line to see if it works using simpleShape instead
                            /*
                            // test if it is SH_Rule02
                            var r2 = ruleObject as SH_Rule02;
                            if (r2 != null)
                            {
                                numLines++; // if true, then a new line can be added to the SH_Simple shape from this rule.
                            }*/

                            ruleObject.NewRuleParameters(random, _ss);
                            // add the rule to the genome
                            genome.Add(ruleObject);

                            // change the state to the one applied by the rule
                            state = ruleObject.GetNextState();
                        }                        
                    }
                    else
                    {
                        throw new Exception("There was an error when taking a rule from the list");
                    }

                    

                }
                else
                {
                    throw new Exception("There was an error when taking the element from the list");
                }
                count++;
            }

            /*
            // apply new rule until the final rule is selected.
            while (state != State.end)
            {
                var randomRule = 
            }
            */



            return genome;
        }
        public static object TestActivator()
        {
            //var objectToInstantiate = typeof(SH_Rule).AssemblyQualifiedName;
            const string objectToInstantiate = "SimpleShapeGrammar.Classes.SH_Rule01, SimpleShapeGrammar";
            var objectType = Type.GetType(objectToInstantiate);

            var instantiateObject = Activator.CreateInstance(objectType) as ISH_Rule; // use the interface to make the "NewRule()" possible

            // test if something can be done with the rule
            Random rnd = new Random();
            instantiateObject.NewRuleParameters(rnd, new SH_SimpleShape()); // Set the translation vectors for this

            return instantiateObject;
        }
        public static object NewRule(string ruleStr)
        {
            // Make this more general to 
            string ruleToInitiate = "SimpleShapeGrammar.Classes." + ruleStr + ", SimpleShapeGrammar";
            Type type = Type.GetType(ruleToInitiate);

            if (type != null)
            {
                return Activator.CreateInstance(type);
            }
            return null;
        }        
    }
}
